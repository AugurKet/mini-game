<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2048</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f1b33; --text:#e8efff; --muted:#9fb3d8; --border:rgba(255,255,255,.10);
    --board:#111c38; --cell:rgba(255,255,255,.08);
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; padding:16px;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial;
    color:var(--text);
    background:
      radial-gradient(900px 500px at 20% 0%, rgba(47,109,255,.18), transparent 60%),
      radial-gradient(900px 500px at 80% 10%, rgba(0,212,255,.12), transparent 55%),
      var(--bg);
    display:flex; justify-content:center; align-items:center;
  }
  .wrap{ width:min(900px,100%); display:grid; grid-template-columns: 1fr 320px; gap:14px; align-items:start; }
  @media(max-width:900px){ .wrap{grid-template-columns:1fr} }

  .panel{
    background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .hd{
    padding:14px; display:flex; justify-content:space-between; align-items:center;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .hd .t{font-weight:900}
  .hd .s{color:var(--muted); font-size:12px}

  .body{ padding:14px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button{
    border-radius:12px; border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;
    font-weight:900;
    cursor:pointer;
  }
  button.primary{
    background: linear-gradient(180deg, rgba(47,109,255,.95), rgba(47,109,255,.60));
    border-color: rgba(47,109,255,.8);
  }
  button.warn{
    background: linear-gradient(180deg, rgba(251,191,36,.95), rgba(251,191,36,.55));
    border-color: rgba(251,191,36,.8);
    color:#1b1300;
  }

  .stats{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px; }
  .stat{
    background: rgba(12,22,43,.55);
    border:1px solid rgba(255,255,255,.06);
    border-radius:14px;
    padding:10px;
  }
  .stat .k{ color:var(--muted); font-size:12px; }
  .stat .v{ font-weight:900; font-size:18px; margin-top:6px; }

  .boardWrap{ display:flex; justify-content:center; }
  .board{
    width:min(520px, 100%);
    aspect-ratio: 1 / 1;
    background: var(--board);
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px;
    padding:12px;
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:12px;
    touch-action: none; /* enable swipe */
    position:relative;
  }
  .cell{
    background: var(--cell);
    border-radius:14px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1000;
    font-size: clamp(22px, 5vw, 42px);
    user-select:none;
    transition: transform .08s ease;
  }
  .cell.pop{ transform: scale(1.05); }

  .msg{
    margin-top:10px;
    background: rgba(12,22,43,.55);
    border:1px solid rgba(255,255,255,.06);
    border-radius:14px;
    padding:10px;
    color: rgba(232,239,255,.92);
    min-height: 52px;
  }
  .msg .k{ color:var(--muted); font-size:12px; margin-bottom:6px; }
  .small{ color:var(--muted); font-size:12px; line-height:1.45; }
  kbd{background:rgba(255,255,255,.08); padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.10)}
</style>
</head>
<body>
<div class="wrap">

  <section class="panel">
    <div class="hd">
      <div class="t">2048</div>
      <div class="s">Swipe or use arrow keys</div>
    </div>
    <div class="body">
      <div class="boardWrap">
        <div id="board" class="board" aria-label="2048 board"></div>
      </div>

      <div class="stats">
        <div class="stat"><div class="k">Score</div><div class="v" id="score">0</div></div>
        <div class="stat"><div class="k">Best</div><div class="v" id="best">0</div></div>
      </div>

      <div class="msg" role="status" aria-live="polite">
        <div class="k">Status</div>
        <div id="log">Combine tiles to reach 2048.</div>
      </div>
    </div>
  </section>

  <aside class="panel">
    <div class="hd">
      <div class="t">Controls</div>
      <div class="s">GitHub Pages ready</div>
    </div>
    <div class="body">
      <div class="row">
        <button class="primary" id="newBtn">New</button>
        <button id="undoBtn">Undo</button>
        <button class="warn" id="resetBestBtn">Reset Best</button>
      </div>
      <div style="height:10px"></div>
      <div class="small">
        Desktop: <kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd> to move, <kbd>U</kbd> Undo<br>
        Mobile: swipe on the board.<br><br>
        Tips: Keep big tiles in a corner. Don‚Äôt break your chain.
      </div>
    </div>
  </aside>

</div>

<script>
(() => {
  const N = 4;
  const boardEl = document.getElementById("board");
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const logEl   = document.getElementById("log");
  const newBtn  = document.getElementById("newBtn");
  const undoBtn = document.getElementById("undoBtn");
  const resetBestBtn = document.getElementById("resetBestBtn");

  const BEST_KEY = "best_2048_v1";

  let grid, score, best, wonShown=false;
  let prev = null; // undo snapshot {grid, score, wonShown}

  function emptyGrid(){
    return Array.from({length:N}, ()=>Array(N).fill(0));
  }
  function cloneGrid(g){ return g.map(r=>r.slice()); }

  function setLog(msg){ logEl.textContent = msg; }

  function loadBest(){
    best = Number(localStorage.getItem(BEST_KEY) || "0");
    bestEl.textContent = best.toLocaleString();
  }
  function saveBest(){
    if(score > best){
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
      bestEl.textContent = best.toLocaleString();
    }
  }

  function randEmptyCell(g){
    const cells=[];
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(g[y][x]===0) cells.push([x,y]);
    if(!cells.length) return null;
    return cells[Math.floor(Math.random()*cells.length)];
  }

  function addTile(g){
    const spot = randEmptyCell(g);
    if(!spot) return false;
    const [x,y] = spot;
    g[y][x] = Math.random() < 0.9 ? 2 : 4;
    return true;
  }

  function canMove(g){
    // empty cell
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(g[y][x]===0) return true;
    // merge possible
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const v=g[y][x];
        if(x+1<N && g[y][x+1]===v) return true;
        if(y+1<N && g[y+1][x]===v) return true;
      }
    }
    return false;
  }

  function compress(line){
    const a = line.filter(v=>v!==0);
    while(a.length<N) a.push(0);
    return a;
  }

  function merge(line){
    // assumes compressed
    let gained = 0;
    for(let i=0;i<N-1;i++){
      if(line[i] && line[i]===line[i+1]){
        line[i] *= 2;
        line[i+1] = 0;
        gained += line[i];
      }
    }
    return {line: compress(line), gained};
  }

  function move(dir){
    // dir: "left" "right" "up" "down"
    const before = cloneGrid(grid);
    const beforeScore = score;
    const beforeWon = wonShown;

    let moved = false;
    let gainedTotal = 0;

    const getLine = (i) => {
      if(dir==="left"||dir==="right"){
        const row = grid[i].slice();
        return dir==="left" ? row : row.reverse();
      } else {
        const col = grid.map(r=>r[i]);
        return dir==="up" ? col : col.reverse();
      }
    };
    const setLine = (i, line) => {
      if(dir==="left"||dir==="right"){
        const out = dir==="left" ? line : line.slice().reverse();
        grid[i] = out;
      } else {
        const out = dir==="up" ? line : line.slice().reverse();
        for(let y=0;y<N;y++) grid[y][i] = out[y];
      }
    };

    for(let i=0;i<N;i++){
      let line = compress(getLine(i));
      const merged = merge(line);
      line = merged.line;
      gainedTotal += merged.gained;

      // detect change
      const original = getLine(i);
      const originalCompressed = compress(original);
      if(JSON.stringify(line) !== JSON.stringify(originalCompressed)) moved = true;

      setLine(i, line);
    }

    if(!moved) return false;

    // save undo snapshot
    prev = { grid: before, score: beforeScore, wonShown: beforeWon };

    score += gainedTotal;
    addTile(grid);
    saveBest();

    if(!wonShown && maxTile(grid) >= 2048){
      wonShown = true;
      setLog("üéâ You reached 2048! Keep going if you want.");
    } else {
      setLog(gainedTotal ? `+${gainedTotal} points` : "Moved.");
    }

    render(true);

    if(!canMove(grid)){
      setLog("Game Over ‚Äî no more moves.");
    }
    return true;
  }

  function maxTile(g){
    let m=0;
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) m=Math.max(m,g[y][x]);
    return m;
  }

  function tileStyle(v){
    // simple dynamic: color intensity based on log2
    if(v===0) return {bg:"rgba(255,255,255,.08)", fg:"rgba(232,239,255,.45)"};
    const k = Math.log2(v);
    const light = Math.max(18, 72 - k*4); // lower light as bigger
    const bg = `hsl(${210 - k*7}, 70%, ${light}%)`;
    const fg = light < 45 ? "#0b1220" : "#0b1220";
    return {bg, fg};
  }

  function render(pop=false){
    boardEl.innerHTML = "";
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const v = grid[y][x];
        const d = document.createElement("div");
        d.className = "cell";
        const st = tileStyle(v);
        d.style.background = st.bg;
        d.style.color = v ? "#0b1220" : "rgba(232,239,255,.45)";
        d.textContent = v ? v : "";
        if(pop && v) d.classList.add("pop");
        boardEl.appendChild(d);
      }
    }
    scoreEl.textContent = score.toLocaleString();
    bestEl.textContent = best.toLocaleString();
  }

  function newGame(){
    grid = emptyGrid();
    score = 0;
    wonShown = false;
    prev = null;
    addTile(grid);
    addTile(grid);
    setLog("Combine tiles to reach 2048.");
    render();
  }

  function undo(){
    if(!prev) { setLog("Nothing to undo."); return; }
    grid = cloneGrid(prev.grid);
    score = prev.score;
    wonShown = prev.wonShown;
    prev = null;
    setLog("Undid last move.");
    render();
  }

  // Keyboard
  window.addEventListener("keydown", (e) => {
    const k = e.key;
    if(k === "ArrowLeft"){ e.preventDefault(); move("left"); }
    if(k === "ArrowRight"){ e.preventDefault(); move("right"); }
    if(k === "ArrowUp"){ e.preventDefault(); move("up"); }
    if(k === "ArrowDown"){ e.preventDefault(); move("down"); }
    if(k === "u" || k === "U"){ undo(); }
  });

  // Swipe
  let sx=0, sy=0, tracking=false;
  boardEl.addEventListener("pointerdown", (e) => {
    tracking = true;
    sx = e.clientX; sy = e.clientY;
    boardEl.setPointerCapture(e.pointerId);
  });
  boardEl.addEventListener("pointerup", (e) => {
    if(!tracking) return;
    tracking = false;
    const dx = e.clientX - sx;
    const dy = e.clientY - sy;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    const TH = 22;
    if(ax < TH && ay < TH) return;
    if(ax > ay){
      move(dx > 0 ? "right" : "left");
    } else {
      move(dy > 0 ? "down" : "up");
    }
  });
  boardEl.addEventListener("pointercancel", ()=> tracking=false);

  // Buttons
  newBtn.addEventListener("click", newGame);
  undoBtn.addEventListener("click", undo);
  resetBestBtn.addEventListener("click", () => {
    localStorage.removeItem(BEST_KEY);
    loadBest();
    setLog("Best score reset.");
  });

  loadBest();
  newGame();
})();
</script>
</body>
</html>
